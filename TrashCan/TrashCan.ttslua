local TrashCan = {}
--------------------------------------------------------------------------------
-- temp debugging functions to be removed
function zprintSorted(SortedTrashContents)
    print('\nSortedTrashContents')
    for k,v in pairs(SortedTrashContents) do
        print('('..tostring(#v)..') : '..k)
    end
end
--------------------------------------------------------------------------------
-- Global Variabels
local debug = require("/_libs/debug")
local zprint = debug.zprint
local tool = {}
      tool.place    = require("/_libs/PositionUtils")
      tool.waitFor  = require("/_libs/WaitUtils")
      tool.findOBJs = require("/_libs/FindObjs")
      tool.string   = require("/_libs/StringUtils")
      tool.cast     = require("/_libs/TrashCan/TrashCast")

local TAGS = {Delete='Delete', SmallCard='Small', LargeCard='Large', Bag='Bag', ScriptZone='ScriptZone', SpecialCase='SpecialCase', Deck='Deck'}
--------------------------------------------------------------------------------
--- Function to Call from EVENT ------------------------------------------------
function TrashCan.process(TrashBag)
    runTrash(TrashBag)
end
--------------------------------------------------------------------------------
--- ProcessBagContents(TrashBag)------------------------------------------------
function runTrash(TrashBag)
    local SortedTrashContents = FindObjsInTrashBagFromData(TrashBag)
    zprintSorted(SortedTrashContents)

    --Wait.frames(function() StartCascade(TrashBag, AllTrashContents) end, 5) -- wait 5 frames to ensure deck spawn properly
end
--------------------------------------------------------------------------------
--- StartCascade(Trashbag, AllTrashContents) -----------------------------------
function StartCascade(TrashBag, AllTrashContents)
    --local ActionList = setActionList(AllTrashContents, TrashBag)
    --zprint(ActionList,'ActionList')
    --local UniqueCastLocations = setUniqueCastLocations(ActionList)
    --zprint(UniqueCastLocations,'UniqueCastLocations')
    --processTrashCanList(ActionList, UniqueCastLocations, TrashBag)
end

function processTrashCanList(ActionList, UniqueCastLocations, TrashBag)
    --zprint(UniqueCastLocations,'UniqueCastLocations')
    for guid,v in pairs(ActionList) do
        --if v.container == TrashBag then
            print(v.GMNotes)
            local pos = UniqueCastLocations[v.GMNotes].platform.getPosition()+Vector(0,5,0)
            local o = v.container.takeObject({})
            o.setPositionSmooth(pos)
        --end
    end
end

--------------------------------------------------------------------------------
--- setUniqueCastLocations(ActionList) -----------------------------------------
function setUniqueCastLocations(ActionList)
    zprint(ActionList,'ActionList')

    local z = {}
    for k,v in pairs(ActionList) do
        for _,tag in pairs(v.Tags) do
            if string.find(string.lower(tag), 'id_', 1, true) then
                --print(tag)
                z[tag] = 'DiscardMe'
            --[[elseif string.find(string.lower(tag), 'discard_bag', 1, true) then
                z[tag] = 'DiscardMe']]
            end
        end
    end

    zprint(z,'z')

    --[[local uniqueList = {} -- uniqueList
    for k,v in pairs(ActionList) do
        uniqueList[v.GMNotes] = v.type
    end
    return tool.cast.findContainer(uniqueList)]]
    return {}
end

--- setActionList(DataList) ----------------------------------------------------
function setActionList(DataList, TrashBag)
    --zprint(DataList,'DataList')
    local ActionList = {}
        for _, deck in pairs(DataList.Deck) do
            for k,v in pairs(deck.getObjects()) do
                ActionList[v] = {type=TAGS.Card, guid=v.guid, Tags=v.tags, container=deck} -- action='move'
            end
        end

        for k,v in pairs(DataList.Card) do
            ActionList[v] = {type=TAGS.Card, guid=v.GUID, Tags=v.Tags, container=TrashBag}
        end

        for k,v in pairs(DataList.Bag) do
            ActionList[v] = {type=TAGS.Bag, guid=v.GUID, Tags=v.Tags, container=TrashBag}
        end

        for k,v in pairs(DataList.ScriptZone) do
            ActionList[v] = {type=TAGS.ScriptZone, guid=v.GUID, Tags=v.Tags, container=TrashBag}
        end

        for k,v in pairs(DataList.Delete) do
            ActionList[v] = {type=TAGS.Delete, guid=v.GUID, Tags=v.Tags, container=TrashBag}
        end

        for k,v in pairs(DataList.SpecialCase) do
            ActionList[v] = {type=TAGS.SpecialCase, guid=v.GUID, Tags=v.Tags, container=TrashBag}
        end

    return ActionList
end
--------------------------------------------------------------------------------
--- FindObjsInTrashBagFromData(TrashBag) ---------------------------------------
function FindObjsInTrashBagFromData(TrashBag)
    local z = {}
        local type = TAGS
        local data_trashContentsALL = TrashBag.getData().ContainedObjects

        if not data_trashContentsALL then
            printToAll('Error : '..TrashBag.getGUID()..' : TRASH EMPTY!!', 'RED') --getData() returned nothing, this should never happen!
        else
            local found_DiscardObjs = tool.findOBJs.vHasAnyTag_DATA(data_trashContentsALL, {'DeleteMe','DiscardMe_'}, true)--Small','DiscardMe_Large','DiscardMe_Bag','DiscardMe_Special','DiscardMe_ScriptZone')
            z = SortObjects(TrashBag, found_DiscardObjs, type)
        end
    return z
end

function SortObjects(TrashBag, found_DiscardObjs, type)
    local delete_ObjList = {}       --
    local explode_DeckList = {}     --
    local move_SmallCardList = {}   --
    local move_LargeCardList = {}     --
    local move_BagList = {}         --
    local move_ScrtipZoneList = {}  --
    local move_SpecialCaseList = {} --

    for _, obj in pairs(found_DiscardObjs) do
        if obj.Tags then
            if obj.Name == 'Card' then
                if tool.findOBJs.tagFound(obj.Tags, {'DiscardMe_'..type.LargeCard}) then
                    table.insert(move_LargeCardList, obj)
                elseif tool.findOBJs.tagFound(obj.Tags, {'DiscardMe_'..type.SmallCard}) then
                    table.insert(move_SmallCardList, obj)
                end

            elseif obj.Name == 'Deck' then
                table.insert(explode_DeckList, obj)

            elseif tool.findOBJs.tagFound(obj.Tags, {'DiscardMe_'..type.SpecialCase}) then
                table.insert(move_SpecialCaseList, obj)

            elseif tool.findOBJs.tagFound(obj.Tags, {'DiscardMe_'..type.ScriptZone}) then
                table.insert(move_ScrtipZoneList, obj)

            elseif tool.findOBJs.tagFound(obj.Tags, {'DiscardMe_'..type.Bag}) then
                table.insert(move_BagList, obj)

            elseif tool.findOBJs.tagFound(obj.Tags, {'DeleteMe'}) then
                table.insert(delete_ObjList, obj)
            end
        end
    end

    local z = {}
        z[type.SpecialCase]  = move_SpecialCaseList
        z[type.ScriptZone]   = move_ScrtipZoneList
        z[type.SmallCard]    = move_SmallCardList
        z[type.LargeCard]    = move_LargeCardList
        z[type.Deck]         = explodeDecks(TrashBag, explode_DeckList)
        z[type.Bag]          = move_BagList
        z[type.Delete]       = delete_ObjList
    return z
end

--- explodeDecks(TrashBag, deckList) -------------------------------------------
function explodeDecks(TrashBag, deckList)
    local z = {}
    for k,v in pairs(deckList) do
        local o = TrashBag.takeObject({guid=v.GUID})
        o.setPosition(tool.place.TopOrBot_ofObject(TrashBag,'top')+Vector(20,0,0))
        o.setRotation(Vector(0,180,180))
        o.setLock(true)
        table.insert(z, o)
    end
    return z
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
return TrashCan
