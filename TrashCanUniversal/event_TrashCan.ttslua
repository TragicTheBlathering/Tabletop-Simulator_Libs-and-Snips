local trashCan_Universal = {}

local tool = require("/_libs/TrashCanUniversal/tools_TrashCan")
local trashSetting = {tag_validTrashOBJ = "trash_DiscardObject",
                      trashID_="trashid_", discardObject='trash_discardobject', discardTarget='trash_discardtarget', specialCase='trash_specialcase', deleteme='trash_deleteme',
                      trashDrop_Yoffset = 1,
                      }

function trashCan_Universal.enterContainer(bag, obj, gVariable)
    local trashSetting = tool.tbls.merge(trashSetting, gVariable)
    if bag.hasTag('event_TrashCan') then
        --printToAll('Trash 00 : runTrash!')
        tool.wait.dropIntoBox(bag, obj, prepTrashBag, time)
    end
end
--------------------------------------------------------------------------------
------ Start Trash Bag Code ----------------------------------------------------

--------------------------------------------------------------------------------
--- remove any decks from the trash and move to processing ---------------------
function prepTrashBag(TrashBag, objData)
    local removedDeckList = nil
    Wait.frames(function()
        removedDeckList = removeDecksFormTrash(TrashBag)
        Wait.frames(function() processBag(TrashBag, removedDeckList) end, 1) -- wait for removed decks to spawn compleatly
    end, 1)

    --printToAll('Trash 01 : runTrash!')
end
--------------------------------------------------------------------------------
--- runTrash -------------------------------------------------------------------
function processBag(TrashBag, removedDeckList)
    local uniqueCast = uniqueCastLocations(TrashBag, removedDeckList)
    processObjectsInList(TrashBag, uniqueCast)
    processRemovedDecks(removedDeckList, uniqueCast)
end

function processRemovedDecks(removedDeckList, uniqueCast)
    print("Make evrything go into a single list then do it all in one loop")
    for k,deck in pairs(removedDeckList) do
        processObjectsInList(deck, uniqueCast)
    end
end

function processObjectsInList(container, uniqueCast)
    local contents = container.getObjects()
    local idex = tool.takeObj.reverseIndex(contents)
    for k,dex in ipairs(idex) do
        local obj = contents[dex+1]
        if obj.tags[1] then
            local id = setIDs(obj.tags)
            if id.validDiscardObj and not id.delete then
                if id.kind == trashSetting.specialCase then
                    print('Special Case - OBJ')
                    --moveSpecialCase(TrashBag.takeObject({index = dex}), TrashBag)
                else
                    --print('Move Case - OBJ')
                    for castID,w in pairs(uniqueCast) do
                        if castID == id.id then
                            moveObject(container.takeObject({index = dex}), container, uniqueCast, id)
                        end
                    end
                end
            end
        end
    end
    --- wait 1 frame after removing discard items, then delete items still in the trash bag set to delete
    Wait.frames(function()
        local contents = container.getObjects()
        local idex = tool.takeObj.reverseIndex(contents)
        for k,dex in ipairs(idex) do
            local obj = contents[dex+1]
            if obj.tags[1] then
                local id = setIDs(obj.tags)
                if id.delete then
                    destroyObject(container.takeObject({index = dex}))
                end
            end
        end
    end, 1)

end
--[[

for k,dex in ipairs(idex) do
    --print(k..' : '..dex)
    local obj = contents[dex+1]
    if obj.tags[1] then
        local id = setIDs(obj.tags)
        --print(logString(id, '\n ---- ID'))
        if id.delete then
            if id.delete then
                destroyObject(container.takeObject({index = dex}))
            end
        else
            if id.validDiscardObj and not id.delete then
                if id.kind == trashSetting.specialCase then
                    print('Special Case - OBJ')
                    --moveSpecialCase(TrashBag.takeObject({index = dex}), TrashBag)
                else
                    --print('Move Case - OBJ')
                    for q,w in pairs(uniqueCast) do
                        if q == id.id then
                            --print(q..' : '..id.id)
                            moveObject(container.takeObject({index = dex}), container, uniqueCast, id)
                            break
                        end
                    end
                end
            end
        end
    end
end

]]
--[[
--print('\n--------------------------------------------')
--print(logString(uniqueCast, '\n--- uniqueCast'))
-- Process the remaining contents of TrashBag (remeber all decks have been removed)
local TrashContents = TrashBag.getObjects()
local idex = tool.takeObj.reverseIndex(TrashContents)
--print(logString(idex,'\n----- iDEX'))
for k,dex in ipairs(idex) do
    --print(k..' : '..dex)
    local obj = TrashContents[dex+1]
    if obj.tags[1] then
        local id = setIDs(obj.tags)
        --print(logString(id, '\n ---- ID'))
        if id.delete then
            if id.delete then
                destroyObject(TrashBag.takeObject({index = dex}))
            end
        else
            if id.validDiscardObj and not id.delete then
                if id.kind == trashSetting.specialCase then
                    print('Special Case - OBJ')
                    --moveSpecialCase(TrashBag.takeObject({index = dex}), TrashBag)
                else
                    --print('Move Case - OBJ')
                    for q,w in pairs(uniqueCast) do
                        if q == id.id then
                            --print(q..' : '..id.id)
                            moveObject(TrashBag.takeObject({index = dex}), TrashBag, uniqueCast, id)
                            break
                        end
                    end
                end
            end
        end
    end
end
--print('\n<------- END')
]]

--******************************************************************************
--- moveObject -----------------------------------------------------------------
--******************************************************************************
-- This gose through list and moves all items into postion. Then once moved calls a "add to deck" function to snap them into place with putObject() rather than just fall via physisc
function moveObject(obj, TrashBag, uniqueCast, id)
    --print('\n --=== Move : moveObject')
    obj.setPosition({-39.49, 10, 20.36})
    --print(logString(id, '\n-- ID'))
    --print(logString(uniqueCast, '\n-- uniqueCast'))

    local key = nil
    if obj.hasTag(id.id) then
        key = id.id
    end

    print(key..' : '..tostring(uniqueCast[key].Y))

    Wait.frames(function()
        obj.setPosition(tool.takeObj.placeTopOrBot_ofObject(TrashBag,'top')+Vector(0,0.2,0))
        uniqueCast[key].Y = uniqueCast[key].Y + getSizeofObj(obj).y+0.2
        --print(key..' : '..tostring(uniqueCast[key].Y))
        obj.setPositionSmooth(tool.takeObj.placeTopOrBot_ofObject(uniqueCast[key].targetToMoveAbove,'top')+Vector(0,uniqueCast[key].Y,0))
        Wait.condition(function() uniqueCast[key].targetToMoveAbove = Wait_AddCardtoDeck(obj, uniqueCast[key]) end, function() return not obj.isSmoothMoving() end)
    end,1)
end

function Wait_AddCardtoDeck(obj, uniqueCastID)--(card, discardZonePos, targetObj)
    local discardPile = uniqueCastID.targetToMoveAbove

    if (uniqueCastID.platform == uniqueCastID.targetToMoveAbove) and obj.type == "Card" then
        --print('No Card or Deck, but OBJ is a Card')
        obj.setPosition(tool.takeObj.placeTopOrBot_ofObject(uniqueCastID.platform,'top'))
        discardPile = obj
    else
        discardPile = discardPile.putObject(obj)
        return discardPile
    end
    return discardPile
end

function getSizeofObj(obj)
    --local size = obj.getBoundsNormalized().size
    local size = obj.getBounds().size
    return size
end
--------------------------------------------------------------------------------
--- removeDecksFormTrash(TrashBag) ---------------------------------------------
function removeDecksFormTrash(TrashBag)
    local z = {}
        local tag = trashSetting.tag_validTrashOBJ
        local type = 'Deck'
        local containedObjects = TrashBag.getData().ContainedObjects

        local indexesToRemove = tool.takeObj.reverseIndex_TagedOnly(tag, containedObjects, 'Deck')

        for i,indexToRemove in ipairs (indexesToRemove) do
            local o = TrashBag.takeObject({ index = indexToRemove })
            o.setPosition(tool.takeObj.placeTopOrBot_ofObject(TrashBag,'top')+Vector(0, 0,-8)) ------------ debug VERSION OF MOVE
            --o.setPosition(tool.placeTopOrBot_ofObject(TrashBag,'top')+Vector(0,-70,0))
            o.setRotation(Vector(0,180,0))
            o.setLock(true)
            table.insert(z, o)
        end
    if z[1] then return z else return {} end
end

--------------------------------------------------------------------------------
--- UniqueCastLocations(TrashBag, removedDeckList) -----------------------------
--- Build a list from trash and find the unique locations for each discard, then cast at that location and return found data.
--- Loop though trash objects and find the "DiscardMe_" Tag.. and then extract the "kind" of discard type as well as the unique Identifyer (ID) of the discard
function uniqueCastLocations(TrashBag, removedDeckList)
    local z = {}
    --print('UniqueCastLocations : processBag!')
    --print(trashSetting.trashID)
    --print(trashSetting.discardTarget)

        for k,obj in ipairs(TrashBag.getObjects()) do
            if obj.tags[1] then
                local id = setIDs(obj.tags)
                --print(logString(id, '\n--- ID'))
                if id.validDiscardObj then
                    z[id.id] = id.kind
                end
            end
        end

        for _, deck in ipairs (removedDeckList) do
            for _, card in ipairs(deck.getObjects()) do
                if card.tags[1] then
                    local id = setIDs(card.tags)
                    if id.validDiscardObj then
                        z[id.id] = id.kind
                    end
                end
            end
        end
        z = tool.cast(z, trashSetting)
        --print(logString(z, '\n ---- z'))
    return z
end


--------------------------------------------------------------------------------
--- setIDs ---------------------------------------------------------------------
-- Go through an obj's tag list and find spesific tags related to the trash functions and add them to a data variable for use latter.
function setIDs(objtags)
    --print('setIDs')
    local tagList = objtags
    local id = {}
    for k,t in pairs(tagList) do
        local tag = string.lower(t)
        if tag == trashSetting.discardObject then
            id.kind = trashSetting.discardTarget
            id.validDiscardObj = true

        elseif tag == trashSetting.specialCase then
            --print(trashSetting.specialCase..' : '..tag)
            id.kind = trashSetting.specialCase
            id.validDiscardObj = true

        elseif tag == trashSetting.deleteme then
            id.delete = true
        end

        for k,t in pairs(tagList) do
            if string.find(string.lower(t), trashSetting.trashID_, 1, true) then
                id.id = tag
            end
        end
    end
    return id
end

return trashCan_Universal
